---
title: "A comprehensive tool suite for CNV analysis"
author:
    - name: Vinicius Henrique da Silva
      affiliation: Animal Breeding and Genomics Center, Wageningen University
      email: vinicius.dasilva@wur.nl
    - name: Ludwig Geistlinger
      affiliation: School of Public Health, City University of New York
      email: ludwig.geistlinger@sph.cuny.edu
package: cnvAnalyzeR
abstract: > 
    The _cnvAnalyzeR_ package implements a comprehensive tool suite for CNV 
    analysis. This includes CNV calling from SNP-chip genotype and 
    next-generation sequencing data, CNV architecture, CNV-expression 
    association, CNV-phenotype association, and CNV evolution.
output:
  BiocStyle::html_document:
    toc: true
    toc_depth: 2
vignette: >
  % \VignetteIndexEntry{A comprehensive tool suite for CNV analysis}
  % \VignetteEngine{knitr::rmarkdown}
---

```{r setup, echo=FALSE}
suppressPackageStartupMessages({ 
    library(cnvAnalyzeR)
})
```

# Setup
Copy number variation (CNV) is a frequently observed deviation from the diploid 
state due to duplication or deletion of genomic regions.

Some papers that we want to cite:

- Genome-wide detection of CNVs and their association with meat tenderness in 
    Nelore cattle
    [da Silva et al., 2016](https://doi.org/10.1371/journal.pone.0157711)

- Distribution and functionality of copy number variation across European cattle
    populations
    [Upadhyay et al., 2017](https://doi.org/10.3389/fgene.2017.00108)

- Widespread modulation of gene expression by copy number variation in skeletal 
    muscle
    [Geistlinger et al., 2018](https://doi.org/10.1038/s41598-018-19782-4)

- CNVs are associated with genomic architecture in a songbird 
    [da Silva et al., 2018](https://doi.org/10.1186/s12864-018-4577-1)

We start by loading the package.

```{r lib}
library(cnvAnalyzeR)
```

# Reading and accessing CNV data

The `r Biocpkg("cnvAnalyzeR")` package uses `r Biocpkg("GenomicRanges")` and 
`r Biocpkg("RaggedExperiment")` to represent, access, and manipulate CNV data.

For demonstration, we consider CNV calls as obtained with 
[PennCNV](http://penncnv.openbioinformatics.org) from SNP-chip data in a 
Brazilian cattle breed. 
[da Silva et al., 2016](https://doi.org/10.1371/journal.pone.0157711)

```{r readCalls}
data.dir <- system.file("extdata", package="cnvAnalyzeR")
call.file <- file.path(data.dir, "Silva16_PONE_CNV_calls.csv")
calls <- read.csv(call.file, as.is=TRUE)
nrow(calls)
head(calls)
```

In total, there are roughly 50,000 calls obtained for 723 samples. 

```{r nrSamples}
length(unique(calls[,"NE_id"]))
```

We group the calls by sample ID, resulting in a `GRangesList`.
Each element of the list corresponds to a sample, and contains the genomic 
coordinates of the CNV calls for this sample (along with the copy number state 
in the `State` metadata column).  

```{r cnvCalls}
grl <- makeGRangesListFromDataFrame(calls, 
    split.field="NE_id", keep.extra.columns=TRUE)
grl
```

The advantage of representing the CNV calls as a `GRangesList` is that it allows
to leverage the comprehensive set of operations on genomic regions implemented 
in the `r Biocpkg("GenomicRanges")` packages.

For instance, sorting of the calls according to their genomic coordinates.

```{r sortCalls}
grl <- sort(grl)
grl
```

An alternative matrix-like representation of the CNV calls can be obtained with 
the `r Biocpkg("RaggedExperiment")` data class. 
It resembles in many aspects the established `r Biocpkg("SummarizedExperiment")`
data class for storing gene expression data as e.g. obtained with RNA-seq. 

```{r RaggedExperiment}
ra <- RaggedExperiment(grl)
ra
```

As apparent from the `dim` slot of the object, it stores the CNV calls in the 
rows and the samples in the columns. 
Note that the CN state is now represented as an assay matrix which can be 
easily accessed and subsetted.   

```{r RaggedExperiment-assay}
assay(ra[1:5,1:5])
```

As for a `r Biocpkg("SummarizedExperiment")`, additional information for 
the samples are annotated in the `colData` slot.
For example, we annotate the steer weight and its feed conversion ratio (FCR).
Feed conversion ratio is the ratio of dry matter intake to live-weight gain. 
A typical range of feed conversion ratios is 4.5 -7.5 with a lower number being 
more desirable as it would indicate that a steer required less feed per pound of
gain.

```{r RaggedExperiment-colData}
weight <- rnorm(ncol(ra), mean=1100, sd=100)
fcr <- rnorm(ncol(ra), mean=6, sd=1.5)
colData(ra)$weight <- round(weight, digits=2)
colData(ra)$fcr <- round(fcr, digits=2)
colData(ra)
```

# Summarizing individual CNV calls across a population

In CNV analysis, it is often of interest to summarize invidual calls across
the population, (i.e. to define CNV regions), for subsequent association
analysis with e.g. phenotype data.

In the simplest case, this just merges overlapping individual calls into 
summarized regions.

However, this typically inflates CNV region size.

The `r Biocpkg("cnvAnalyzeR")` package implements three frequently used
approaches for summarizing CNV calls:

1. The [CNVRuler](http://www.ircgp.com/CNVRuler) procedure that trims region 
   margins based on regional density 
   [Kim et al., 2012](https://doi.org/10.1093/bioinformatics/bts239), 
2. the reciprocal overlap (RO) procedure that requires calls to sufficiently 
   overlap with one another 
   [Conrad et al., 2010](https://doi.org/10.1038/nature08516), and
3. the [GISTIC](http://www.broadinstitute.org/cancer/cga/gistic) procedure that
   identifies recurrent CNV regions 
   [Mermel et al., 2011](https://doi.org/10.1186/gb-2011-12-4-r41).


## Trimming low-density areas

Here, we use the approach from [CNVRuler](http://www.ircgp.com/CNVRuler) 
to summarize CNV calls to CNV regions (see 
[Figure 1](https://academic.oup.com/view-large/figure/83392426/bts239f1.jpeg)
in 
[Kim et al., 2012](https://doi.org/10.1093/bioinformatics/bts239)
an illustration of the approach). 

```{r cnvrs}
cnvrs <- populationRanges(grl, density=0.1)
cnvrs
```

## Reciprocal overlap

We also provide an implementation of the _Reciprocal Overlap (RO)_ procedure.


## Identifying recurrent regions

A `GISTIC`-like procedure for detecting recurrent CNVs is also in preparation.

# Overlap analysis of CNVs with functional genomic regions

Here, we compare the CNV overlap with distinct features in the genome using the `r Biocpkg("regioneR")` package.

# CNV-expression association analysis

Here, we analyze differences in expression between CN states based on the
`r Biocpkg("edgeR")` package.

# CNV-phenotype association analysis

Here, we analyze the genome-wide association (GWAS) of CNVs with quantitative phenotypes
using `PLINK` association analysis for copy number polymorphisms (http://zzz.bwh.harvard.edu/plink/gvar.shtml) and GDS files from `r Biocpkg("gdsfmt")` package. For demonstration we use
CNV data of a wild population of songbirds [da Silva et al., 2018](https://doi.org/10.1371/journal.pone.0157711).
The response variable is their breeding time which is represented as the genetic potential for laying date (i.e genomic estimated breeding values - GEBV). Here, the GEBV values are used 
as the response variable in the `PLINK` linear model to pinpoint the genomic regions where the change in copy number is 
associated with change in the genetic potential for breeding time. First, phenotypes, CNV calls and the probe map (if available) 
are imported and all the necessary information is stored in the `phen.info` R object:


```{r importPhen}
folder.package <- system.file('extdata', package = 'cnvAnalyzeR')

phen.info <- setupCnvGWAS(name="Example", phen.loc=file.path(folder.package, "Pheno.txt"), ## GEBV values
cnv.out.loc = file.path(folder.package, "CNVOut.txt"), ## CNV calls            
map.loc = file.path(folder.package, "MapPenn.txt")) ## Genomic positions of the SNPs used in the CNV call

```

The `phen.info` is a list which contains necessary information for the CNV-GWAS procedure itself. The last item of the list
displays the working directory:

```{r Wdir}
all.paths <- phen.info$all.paths
```

After creating the working directories and importing the necessary files, the CNV-GWAS can be performed as follows:

```{r CNVGWAS}
segs.pvalue.gr <- cnvGWAS(phen.info)
```

If the dataset contains chromosome names which are not numeric, they may be changed to numeric within the input files 
containing the CNV calls and probe positions (i.e. SNP map). Thus, the user may provide a data-frame with 
the correspondent character names. In the example, as the great tits don't have the chromosome 16 this number was used for the
chromosome 1A and numbers above 28 were then used to tag the other non-numeric chromosome names. In doing so, the results will output the 
non-numeric chromosome names accordinly.

```{r CNVGWASNames}
# Define chr correspondence to numeric
df <- "16 1A
25 4A
29 25LG1
30 25LG2
31 LGE22"
 
chr.code.name <- read.table(text=df, header=FALSE)

# Run the CNV-GWAS
segs.pvalue.gr <- cnvGWAS(phen.info, chr.code.name=chr.code.name)
```


The CNV-GWAS uses the concept of CNV segments to define CNV loci. This procedure was originally proposed in our previous work in Nelore beef cattle [da Silva et al., 2016](https://doi.org/10.1371/journal.pone.0157711) and defines the CNV segments based on CNV genotype similarity of subsequent SNP probes. The default is `min.sim=0.95`, which will continuously add probes positions to a given CNV segment until the pairwise genotype similarity drops below 95%. Detailed up-down CNV genotype concordance that are used for the construction of CNV segments will look like the S12 Table in  [da Silva et al., 2016](https://doi.org/10.1371/journal.pone.0157711). Although this information is used for the construction of the CNV segments, this is not exported to the user. 

As the `PLINK` provides one separately p-value for each SNP probe, only one of the p-values of the probes overlapping each CNV segment is assigned as the segment p-value. The chosen probe/p-value can be based on the probe with lowest p-value (`assign.probe="min.pvalue"`, default) or the one with highest CNV frequency (`assign.probe="high.freq"`). Once all CNV segments have a p-value assigned, a correction for multiple testing is performed based on the number of CNV segments (FDR is default) and the results can therefore exported as a manhattan plot. 

```{r manh}

## Define the chromosome order in the plot
order.chrs <- c("1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "17", "18", "19",
                "20", "21", "22", "23", "24", "25LG1", "25LG2", "26", "27", "28", "LGE22", "1A", "4A")

## Chromosome sizes
chr.sizes <- c(114059860,150265477,111636321,68030631,61875929,34342011,37653027, 31324166,25106277,20202851,20315886,20466350,16480340,16193477,
13820886,10486032,11572643,9871655,14661763,7693166,4276343, 6655392,6808513,1092960,809223,6596997,4327975,5101010, 773534,71365269,19934923)

chr.size.order <- cbind(as.data.frame(order.chrs, stringsAsFactors = FALSE),as.data.frame(chr.sizes,  stringsAsFactors = FALSE))
colnames(chr.size.order) <- c("chr", "sizes")

## Plot a pdf file with a manhatthan within the 'Results' workfolder
plotManhattan(all.paths, segs.pvalue.gr, "p-value", chr.size.order)

```

Alternatively, the user can use the relative signal intensity (log R ratio - LRR) to perform a GWAS analysis. CNV detection using SNP-chip intensities and allele frequencies are usually challenging and can produce biased CNV frequencies [da Silva et al., 2018](https://doi.org/10.1186/s12864-018-4577-1). Thus, GWAS using LRR values directly may help to identify CNV segments which are possibly associated with phenotypes but have their frequency biased by the CNV calling procedure. Therefore, the `cnvGWAS` function allows the user to perform associations with LRR values instead absolute copy numbers. To perform the GWAS using LRR values is necessary to import the LRR/BAF values and state `run.lrr=TRUE` in the `cnvGWAS` function:

```{r importLRR}
# List files to import LRR/BAF 
list.of.files <- list.files(path = folder.package, pattern = "\\.cnv.txt.adjusted$")
list.of.files <- as.data.frame(list.of.files)
colnames(list.of.files)[1] <- "file.names"
list.of.files$sample.names <- gsub(".cnv.txt.adjusted","", list.of.files$file.names)
 
# All missing samples will have LRR = '0' and BAF = '0.5' in all SNPs listed in the GDS file
importLRR_BAF(all.paths, folder.package, list.of.files)

# Read the GDS to check if the LRR/BAF nodes were added
(genofile <- SNPRelate::snpgdsOpen(file.path(all.paths[1], "CNV.gds"), allow.fork=TRUE, readonly=FALSE)) ## read GDS

# Run the CNV-GWAS
segs.pvalue.gr <- cnvGWAS(phen.info, chr.code.name=chr.code.name, run.lrr=TRUE)
```

It is important to note that the `cnvGWAS` function uses the `CNV.gds` file which is stored in the `Inputs` folder (i.e. `all.paths[1]`), This GDS file is automatically generated during a GWAS run. Therefore, running a GWAS implies that any GDS file produced by previous analysis will be overwritten. To avoid overwriting, the user should include `produce.gds=FALSE` in the GWAS run. For convenience, is possible to produce a GDS file before the GWAS analysis with `prodGdsCnv` function, which will additionally retrieve a `GRanges` object containing the genomic positions, names and frequencies of each of the probes which will be used to construct the CNV segments during the GWAS analysis. Note that `probes.cnv.gr` object will hold the numeric chromosome names, such as the GDS file in disk. Only the object `segs.pvalue.gr`, which encloses the GWAS results, has the character names indicated for each chromosome.  

```{r prodGDS}
## Create a GDS file in disk and export the SNP probe positions
probes.cnv.gr <- prodGdsCnv(phen.info, chr.code.name=chr.code.name)

## Run GWAS with existent GDS file
segs.pvalue.gr <- cnvGWAS(phen.info, chr.code.name=chr.code.name, produce.gds=FALSE)
```



